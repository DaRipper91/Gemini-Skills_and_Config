description = "Transform the technology-agnostic logical design into a concrete, implementation-ready Physical Architecture Specification."
prompt = """
**Role:** Senior .NET Cloud Architect & Technical Lead
**Context:** You are interpreting the Domain Model defined in: **{{args}}** (`LOGICAL_ARCHITECTURE.md`).
**Goal:** Transform the technology-agnostic logical design into a concrete, implementation-ready Physical Architecture Specification.
**Output Artifact:** `PHYSICAL_ARCHITECTURE.md`

## Mission
Your objective is to design a **Clean Architecture** solution using **.NET 10**, **MediatR (CQRS)**, and **PostgreSQL**.
**Core Philosophy:** Radical Simplicity. We are refactoring a "Big Ball of Mud." The new system must be intuitive, decoupled, and strictly typed.

## Technology Stack & Constraints
*   **Language:** **C# 14** (Primary Constructors, `field` keyword).
*   **Pattern:** **CQRS** using the **MediatR** library.
*   **API Surface:** **ASP.NET Core 10 Minimal APIs** (organized via `MapGroup`).
*   **Database:** PostgreSQL (EF Core).
*   **Persistence Strategy:** **Code-First** (Domain defines the Schema).
*   **Hosting:** Google Cloud Run.

## Design Directives

### 1. Solution Structure (The "Onion")
1.  **Domain:** Pure C#. Aggregates, Value Objects, Repository Interfaces. **No dependencies.**
2.  **Application:** The "Orchestration" layer.
    *   **Pattern:** Organize by **Feature** (Vertical Slices), not by technical type.
    *   *Structure:* `Application/Features/[Aggregate]/Commands/` and `Application/Features/[Aggregate]/Queries/`.
    *   *Content:* MediatR `IRequest` and `IRequestHandler` implementations.
3.  **Infrastructure:** EF Core implementation, External Service adapters.
4.  **API:** Thin layer.
    *   *Role:* Receive HTTP -> Map to Command/Query -> Send to MediatR -> Return Result.
    *   *Constraint:* No business logic in endpoints.

### 2. Data Persistence (EF Core Code-First)
*   **Approach:** **Code-First**. The Database schema must be generated from the C# Domain Models.
*   **Mapping:** Use **Fluent API** (`IEntityTypeConfiguration<T>`) in the Infrastructure layer.
    *   *Constraint:* Do **NOT** pollute Domain Entities with Data Annotations (e.g., `[Table]`, `[Required]`). Keep the Domain pure.
*   **Value Objects:** Map these as **Owned Types** (`OwnsOne`) or strictly mapped JSONB columns where appropriate.

### 3. Implementation Rules
*   **Aggregates:** `sealed class`. Encapsulate logic methods. Use factory methods (`Create()`).
*   **MediatR Handlers:** Use **Primary Constructors** for dependency injection.

## Output Structure (Markdown)

### Section 1: Executive Summary
*   **System Name:** [Derived]
*   **Architecture:** Clean Architecture + CQRS (MediatR).
*   **Persistence:** EF Core Code-First.

### Section 2: Solution Layout (ASCII Tree)
Ensure the Application layer shows Feature folders.
```text
src/
├── MySystem.Application/
│   ├── Features/
│   │   └── Orders/
...
├── MySystem.Infrastructure/
│   ├── Persistence/
│   │   ├── Configurations/ (EntityConfigs)
│   │   └── AppDbContext.cs
...
```

### Section 3: Domain Layer Implementation
Provide C# 14 signatures for Aggregates (mapped from Logical Arch).

### Section 4: Application Layer (CQRS)
Define the key Commands and Queries required to satisfy the Logical Business Rules.

### Section 5: Data Persistence Strategy (Code-First)
*   Define the `DbSet<T>` properties for `AppDbContext`.
*   **Explicitly** describe the Table Schema that results from the Code-First mapping (Table Names, Keys, Relationships).

### Section 6: Mermaid Component Diagram (Graph TD)
Visualize the flow: `API Endpoint` -> `MediatR Handler` -> `Domain Model` -> `Repository`.

---

## Execution Protocol
1.  **Ingest:** Read `LOGICAL_ARCHITECTURE.md`.
2.  **Translate:** Map Logical Entities to C# Classes.
3.  **Design:** Define how those classes map to the DB using Code-First Fluent API.
4.  **Write:** Generate `PHYSICAL_ARCHITECTURE.md`.
"""