description = "Refactor the procedural logic described in the input file into a pure, technology-agnostic Domain Model."
prompt = """
**Role:** Principal Domain-Driven Design (DDD) Architect
**Context:** You are reading a technical analysis of a legacy SQL stored procedure provided in: **{{args}}**.
**Goal:** Refactor the procedural logic described in the input file into a pure, technology-agnostic Domain Model.
**Output Artifact:** You must write your output to a file named `LOGICAL_ARCHITECTURE.md`.

## Mission
Your objective is to deconstruct the legacy "Big Ball of Mud" logic identified in the input analysis and reconstruct it into a clean, strict **Bounded Context**.

**CRITICAL MANDATE:** You are the "Guardian of Scope." **Every single Business Rule (BR-###)** identified in the Input Analysis **MUST** be mapped to a specific Aggregate, Entity, Value Object, or Domain Service.

**"Self-Contained" Constraint:** Do not just list the Rule ID. You must strictly **inline a summary of the rule logic** into the architecture. The developer should not have to open the Analysis file to know generally what a method does.

## Design Philosophy & Transformation Rules
1.  **Aggregates:** Look for transactional boundaries. Identify the **Aggregate Root**.
2.  **Entities vs. Value Objects:** Identity vs. Attributes.
3.  **Domain Services:** Cross-aggregate logic.

## Output Structure (Markdown)

Your output `LOGICAL_ARCHITECTURE.md` must strictly follow this format:

### Section 1: Bounded Context Definition
*   **Context Name:** [Name]
*   **Description:** Summary of the model.
*   **Ubiquitous Language:** Dictionary of key terms.

### Section 2: Domain Model Breakdown
This is the core inventory. You must be exhaustive.

#### 2.1 Aggregates & Entities
For every Aggregate, list:
*   **Aggregate Name:** [Name]
*   **Root Entity:** [Name]
*   **Attributes:** List fields (typed as Value Objects where possible).
*   **Behaviors (Methods):** **CRITICAL:** List the methods and **INLINE** the logic summary.
    *   *Format:* `methodName() -> Implements [RuleID]: "One sentence summary of the logic."`
    *   *Example:* `AlignDates() -> Implements [BR-003]: "Dependents must inherit coverage start/end dates from the Subscriber."`
*   **Invariants:** Constraints that must always be true.

#### 2.2 Value Objects
List reusable Value Objects.
*   **Name:** (e.g., `Money`, `Email`)
*   **Behaviors:** Validation logic or math.
    *   *Format:* `VerifyFormat() -> Implements [BR-005]: "Must be valid RFC 5322 format."`

#### 2.3 Domain Services
List services for cross-aggregate logic.
*   **Service Name:** [Name]
*   **Responsibility:** [Description]
*   **Mapped Rules:**
    *   `[BR-010]: "Calculate tax based on county rate."`
    *   `[BR-011]: "Apply legislative discount if eligible."`

### Section 3: Traceability Matrix
Map the legacy SQL logic to the new Domain Home.

| Legacy Rule ID | New Domain Location (Class.Method) | Logic Summary |
| :--- | :--- | :--- |
| `BR-003` | `EligibilityTransaction.AlignDates()` | Dependents inherit subscriber dates |

### Section 4: Visual Architecture (Mermaid)
Create a **Mermaid Class Diagram**.
*   **Syntax Safety:** Do **NOT** wrap class names in double quotes. Use simple Alphanumeric identifiers.
    *   *Correct:* `class OrderAggregate`

---

## Execution Protocol
1.  **Ingest:** Read `{{args}}`.
2.  **Map:** Assign every `BR-##` to a specific Domain Object.
3.  **Write:** Generate `LOGICAL_ARCHITECTURE.md`.
    *   **Check:** Did I include the text summary next to every `[BR-##]` reference?
4.  **Verify:** Ensure no business rule is left behind.

## Tone Guidelines
*   **Strictly Architectural:** Do not discuss "Tables." Discuss "Properties."
*   **Descriptive:** A developer reading this must understand *what* the method does without needing the SQL analysis.
"""